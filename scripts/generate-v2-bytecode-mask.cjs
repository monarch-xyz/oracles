const fs = require("node:fs");
const path = require("node:path");

const ROOT = process.cwd();
const REAL_INPUT_TEST = path.join(ROOT, "tests", "bytecode-real-input.test.ts");
const OUTPUT_FILE = path.join(ROOT, "src", "bytecodes", "morpho-chainlink-oracle-v2-mask.ts");

function normalizeBytecode(bytecode) {
  let hex = bytecode.toLowerCase();
  if (hex.startsWith("0x")) hex = hex.slice(2);

  let result = "";
  let i = 0;

  while (i < hex.length) {
    const opcode = hex.slice(i, i + 2);
    result += opcode;
    i += 2;

    if (opcode === "7f" && i + 64 <= hex.length) {
      result += "0".repeat(64);
      i += 64;
    }
  }

  return `0x${result}`;
}

function extractConst(source, constName) {
  const regex = new RegExp(`const\\s+${constName}\\s*=\\s*"([\\s\\S]*?)";`);
  const match = source.match(regex);
  if (!match) {
    throw new Error(`Could not find ${constName} in tests/bytecode-real-input.test.ts`);
  }
  return match[1].replace(/\s+/g, "");
}

function maskByIgnoredByteIndices(normalizedBytecode, ignoredByteIndices) {
  const hex = normalizedBytecode.startsWith("0x")
    ? normalizedBytecode.slice(2)
    : normalizedBytecode;
  const bytes = hex.match(/../g) || [];

  for (const byteIndex of ignoredByteIndices) {
    if (byteIndex >= 0 && byteIndex < bytes.length) {
      bytes[byteIndex] = "00";
    }
  }

  return `0x${bytes.join("")}`;
}

function main() {
  const shouldWrite = process.argv.includes("--write");
  const source = fs.readFileSync(REAL_INPUT_TEST, "utf8");
  const rawA = extractConst(source, "REAL_V2_BYTECODE");
  const rawB = extractConst(source, "REAL_V2_BYTECODE_2");

  if (rawA === "0x" || rawB === "0x") {
    throw new Error(
      "REAL_V2_BYTECODE and REAL_V2_BYTECODE_2 must both be set in tests/bytecode-real-input.test.ts",
    );
  }

  const normalizedA = normalizeBytecode(rawA);
  const normalizedB = normalizeBytecode(rawB);

  if (normalizedA.length !== normalizedB.length) {
    throw new Error(
      `Normalized lengths differ: A=${normalizedA.length}, B=${normalizedB.length}. Cannot build mask safely.`,
    );
  }

  const hexA = normalizedA.slice(2);
  const hexB = normalizedB.slice(2);
  const byteCount = hexA.length / 2;
  const ignoredByteIndices = [];

  for (let i = 0; i < byteCount; i += 1) {
    const aByte = hexA.slice(i * 2, i * 2 + 2);
    const bByte = hexB.slice(i * 2, i * 2 + 2);
    if (aByte !== bByte) {
      ignoredByteIndices.push(i);
    }
  }

  const maskedTarget = maskByIgnoredByteIndices(normalizedA, ignoredByteIndices);

  const output = `/**\n * Auto-generated by scripts/generate-v2-bytecode-mask.cjs\n * Source inputs: tests/bytecode-real-input.test.ts\n */\nexport const MORPHO_V2_MASKED_NORMALIZED_TARGET =\n  "${maskedTarget}";\n\n/**\n * Byte indices in normalized bytecode to ignore before comparison.\n */\nexport const MORPHO_V2_IGNORED_BYTE_INDICES = [${ignoredByteIndices.join(", ")}] as const;\n`;

  console.log("=== Paste This Into src/bytecodes/morpho-chainlink-oracle-v2-mask.ts ===");
  console.log(output);
  console.log("=== End Paste ===");
  console.log(`normalized-length=${normalizedA.length}`);
  console.log(`ignored-byte-count=${ignoredByteIndices.length}`);

  if (shouldWrite) {
    fs.writeFileSync(OUTPUT_FILE, output);
    console.log(`Wrote ${OUTPUT_FILE}`);
  } else {
    console.log("No file written. Run with --write to update file automatically.");
  }
}

main();
